<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Analyzer - CybICS</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #ff6b00;
        }

        header {
            background-color: #2d2d2d;
            color: #ff6b00;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #404040;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .nav-button {
            background-color: #404040;
            color: #ff6b00;
            border: 1px solid #ff6b00;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
            display: inline-block;
        }

        .nav-button:hover {
            background-color: #ff6b00;
            color: #1a1a1a;
        }

        .toolbar {
            background-color: #2d2d2d;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #404040;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .toolbar button {
            background-color: #404040;
            color: #ffffff;
            border: 1px solid #606060;
            border-radius: 0.25rem;
            padding: 0.4rem 1rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .toolbar button:hover:not(:disabled) {
            background-color: #606060;
        }

        .toolbar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toolbar button.active {
            background-color: #ff6b00;
            color: #1a1a1a;
            border-color: #ff6b00;
        }

        .toolbar input, .toolbar select {
            background-color: #404040;
            color: #ffffff;
            border: 1px solid #606060;
            border-radius: 0.25rem;
            padding: 0.4rem 0.8rem;
            font-size: 0.9rem;
        }

        .toolbar label {
            color: #cccccc;
            font-size: 0.9rem;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 120px);
        }

        .view-tabs {
            display: flex;
            gap: 0.5rem;
            background-color: #2d2d2d;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid #404040;
        }

        .tab-button {
            background-color: #404040;
            color: #ffffff;
            border: 1px solid #606060;
            border-radius: 0.25rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-button:hover {
            background-color: #606060;
        }

        .tab-button.active {
            background-color: #ff6b00;
            color: #1a1a1a;
            border-color: #ff6b00;
        }

        .view-content {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        .view-content.active {
            display: flex;
            flex-direction: column;
        }

        #graphCanvas {
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            cursor: grab;
        }

        #graphCanvas:active {
            cursor: grabbing;
        }

        .graph-container {
            position: relative;
            flex: 1;
            overflow: hidden;
        }

        .graph-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 10;
        }

        .graph-controls button {
            background-color: #2d2d2d;
            color: #ff6b00;
            border: 1px solid #ff6b00;
            border-radius: 0.25rem;
            padding: 0.5rem;
            cursor: pointer;
            font-size: 1.2rem;
            width: 40px;
            height: 40px;
        }

        .graph-controls button:hover {
            background-color: #ff6b00;
            color: #1a1a1a;
        }

        .graph-legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: #2d2d2dd0;
            border: 1px solid #404040;
            border-radius: 0.5rem;
            padding: 1rem;
            max-width: 300px;
        }

        .legend-title {
            color: #ff6b00;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .statistics-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background-color: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 0.5rem;
            padding: 1rem;
        }

        .stat-card h3 {
            color: #ff6b00;
            font-size: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #404040;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #303030;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: #cccccc;
            font-size: 0.9rem;
        }

        .stat-value {
            color: #ffffff;
            font-weight: bold;
            font-size: 0.9rem;
        }

        .endpoint-table {
            width: 100%;
            margin-top: 1rem;
        }

        .endpoint-table th {
            background-color: #404040;
            color: #ff6b00;
            padding: 0.75rem;
            text-align: left;
            font-size: 0.85rem;
            position: sticky;
            top: 0;
        }

        .endpoint-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #303030;
            font-size: 0.85rem;
        }

        .endpoint-table tbody tr:hover {
            background-color: #252525;
        }

        .protocol-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .badge-modbus { background-color: #ff6b6b; color: #1a1a1a; }
        .badge-s7comm { background-color: #ffd93d; color: #1a1a1a; }
        .badge-opcua { background-color: #a8e6cf; color: #1a1a1a; }
        .badge-enip { background-color: #ff8b94; color: #1a1a1a; }
        .badge-tcp { background-color: #66ccff; color: #1a1a1a; }
        .badge-udp { background-color: #99ff99; color: #1a1a1a; }
        .badge-other { background-color: #666; color: #ffffff; }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #404040;
            border-radius: 0.25rem;
            overflow: hidden;
            margin-top: 0.25rem;
        }

        .progress-fill {
            height: 100%;
            background-color: #ff6b00;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .packet-list {
            flex: 1;
            overflow-y: auto;
            background-color: #1a1a1a;
            border-bottom: 1px solid #404040;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        thead {
            position: sticky;
            top: 0;
            background-color: #2d2d2d;
            z-index: 10;
        }

        th {
            padding: 0.6rem;
            text-align: left;
            border-bottom: 2px solid #ff6b00;
            font-weight: bold;
            color: #ff6b00;
            white-space: nowrap;
        }

        td {
            padding: 0.5rem 0.6rem;
            border-bottom: 1px solid #303030;
            white-space: nowrap;
        }

        tbody tr {
            cursor: pointer;
            transition: background-color 0.1s;
        }

        tbody tr:hover {
            background-color: #252525;
        }

        tbody tr.selected {
            background-color: #404040;
        }

        .packet-details {
            height: 300px;
            background-color: #1a1a1a;
            border-top: 2px solid #404040;
            overflow-y: auto;
            padding: 1rem;
            font-size: 0.85rem;
        }

        .packet-details h3 {
            color: #ff6b00;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }

        .packet-details .layer {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background-color: #2d2d2d;
            border-left: 3px solid #ff6b00;
        }

        .packet-details .layer-title {
            font-weight: bold;
            color: #ff6b00;
            margin-bottom: 0.5rem;
        }

        .packet-details .field {
            margin-left: 1rem;
            color: #cccccc;
            line-height: 1.6;
        }

        .packet-details .field-name {
            color: #66ccff;
        }

        .packet-details .field-value {
            color: #99ff99;
        }

        .protocol-tcp { color: #66ccff; }
        .protocol-udp { color: #99ff99; }
        .protocol-icmp { color: #ffcc66; }
        .protocol-http { color: #ff99cc; }
        .protocol-dns { color: #cc99ff; }
        .protocol-arp { color: #ffaa66; }
        .protocol-modbus { color: #ff6b6b; font-weight: bold; }
        .protocol-s7comm { color: #ffd93d; font-weight: bold; }
        .protocol-opcua { color: #a8e6cf; font-weight: bold; }
        .protocol-enip { color: #ff8b94; font-weight: bold; }
        .protocol-other { color: #cccccc; }

        .status-bar {
            background-color: #2d2d2d;
            padding: 0.5rem 1rem;
            border-top: 1px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: #cccccc;
        }

        .status-item {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .recording-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #666;
        }

        .recording-indicator.active {
            background-color: #ff0000;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .no-data {
            padding: 2rem;
            text-align: center;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <header>
        <h1>🦈 Sharky - Network Analyzer</h1>
        <a href="/" class="nav-button">← Back to Dashboard</a>
    </header>

    <div class="toolbar">
        <button id="startBtn" onclick="startCapture()">▶ Start</button>
        <button id="stopBtn" onclick="stopCapture()" disabled>⏹ Stop</button>
        <button onclick="clearCapture()">🗑 Clear</button>

        <div style="border-left: 1px solid #606060; height: 30px; margin: 0 0.5rem;"></div>

        <label for="interfaceSelect">Interface:</label>
        <select id="interfaceSelect">
            <option value="all">All</option>
        </select>

        <label for="filterInput">Filter:</label>
        <input type="text" id="filterInput" placeholder="e.g., tcp, udp, port 80" style="width: 200px;">
        <button onclick="applyFilter()">Apply</button>

        <div style="flex: 1;"></div>

        <button onclick="exportCapture()">💾 Export PCAP</button>
    </div>

    <div class="view-tabs">
        <button class="tab-button active" onclick="switchView('packets', event)">📊 Packet List</button>
        <button class="tab-button" onclick="switchView('graph', event)">🔗 Network Graph</button>
        <button class="tab-button" onclick="switchView('statistics', event)">📈 Statistics</button>
    </div>

    <div class="main-container">
        <!-- Packet List View -->
        <div id="packetsView" class="view-content active">
            <div class="packet-list">
            <table>
                <thead>
                    <tr>
                        <th>No.</th>
                        <th>Time</th>
                        <th>Source</th>
                        <th>Destination</th>
                        <th>Protocol</th>
                        <th>Length</th>
                        <th>Info</th>
                    </tr>
                </thead>
                <tbody id="packetTableBody">
                    <tr>
                        <td colspan="7" class="no-data">No packets captured. Click "Start" to begin capturing network traffic.</td>
                    </tr>
                </tbody>
            </table>
        </div>

            <div class="packet-details" id="packetDetails">
                <div class="no-data">Select a packet to view details</div>
            </div>
        </div>

        <!-- Network Graph View -->
        <div id="graphView" class="view-content">
            <div class="graph-container">
                <canvas id="graphCanvas"></canvas>

                <div class="graph-controls">
                    <button onclick="graphZoomIn()" title="Zoom In">+</button>
                    <button onclick="graphZoomOut()" title="Zoom Out">−</button>
                    <button onclick="graphResetView()" title="Reset View">⟲</button>
                    <button onclick="graphAutoLayout()" title="Auto Layout">⚡</button>
                </div>

                <div class="graph-legend">
                    <div class="legend-title">Network Nodes</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff6b6b;"></div>
                        <span>Industrial Devices</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #66ccff;"></div>
                        <span>Network Devices</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #99ff99;"></div>
                        <span>Other Devices</span>
                    </div>
                    <div class="legend-title" style="margin-top: 0.5rem;">Connections</div>
                    <div class="legend-item">
                        <div style="width: 40px; height: 3px; background-color: #ff6b6b;"></div>
                        <span>Modbus</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 40px; height: 3px; background-color: #ffd93d;"></div>
                        <span>S7comm</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 40px; height: 3px; background-color: #a8e6cf;"></div>
                        <span>OPC-UA</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 40px; height: 3px; background-color: #ff8b94;"></div>
                        <span>EtherNet/IP</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 40px; height: 3px; background-color: #66ccff;"></div>
                        <span>TCP/UDP</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Statistics View -->
        <div id="statisticsView" class="view-content">
            <div class="statistics-container">
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>📦 Capture Summary</h3>
                        <div class="stat-row">
                            <span class="stat-label">Total Packets</span>
                            <span class="stat-value" id="stats-total-packets">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Total Bytes</span>
                            <span class="stat-value" id="stats-total-bytes">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Capture Duration</span>
                            <span class="stat-value" id="stats-duration">0:00</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Packets/Second</span>
                            <span class="stat-value" id="stats-pps">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Average Packet Size</span>
                            <span class="stat-value" id="stats-avg-size">0 bytes</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <h3>🔌 Protocol Distribution</h3>
                        <div id="protocol-stats"></div>
                    </div>

                    <div class="stat-card">
                        <h3>🌐 Endpoints</h3>
                        <div class="stat-row">
                            <span class="stat-label">Unique IP Addresses</span>
                            <span class="stat-value" id="stats-unique-ips">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Active Connections</span>
                            <span class="stat-value" id="stats-connections">0</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Industrial Devices</span>
                            <span class="stat-value" id="stats-industrial">0</span>
                        </div>
                    </div>

                    <div class="stat-card">
                        <h3>⚡ Top Ports</h3>
                        <div id="port-stats"></div>
                    </div>
                </div>

                <div class="stat-card">
                    <h3>📊 Endpoint Details</h3>
                    <table class="endpoint-table">
                        <thead>
                            <tr>
                                <th>IP Address</th>
                                <th>Type</th>
                                <th>Packets Sent</th>
                                <th>Packets Received</th>
                                <th>Total Packets</th>
                                <th>Bytes</th>
                                <th>Protocols</th>
                            </tr>
                        </thead>
                        <tbody id="endpoint-table-body">
                        </tbody>
                    </table>
                </div>

                <div class="stat-card" style="margin-top: 1rem;">
                    <h3>🔗 Connection Matrix</h3>
                    <table class="endpoint-table">
                        <thead>
                            <tr>
                                <th>Source</th>
                                <th>Destination</th>
                                <th>Protocol</th>
                                <th>Packets</th>
                                <th>Ports</th>
                            </tr>
                        </thead>
                        <tbody id="connection-table-body">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <div class="recording-indicator" id="recordingIndicator"></div>
            <span id="statusText">Stopped</span>
        </div>
        <div class="status-item">
            <span>Packets: <strong id="packetCount">0</strong></span>
        </div>
        <div class="status-item">
            <span>Displayed: <strong id="displayedCount">0</strong></span>
        </div>
        <div class="status-item">
            <span>Capture Time: <strong id="captureTime">0:00</strong></span>
        </div>
    </div>

    <script>
        let capturing = false;
        let packets = [];
        let displayedPackets = [];
        let selectedPacketId = null;
        let packetCounter = 0;
        let captureStartTime = null;
        let captureTimer = null;
        let updateInterval = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadInterfaces();
        });

        async function loadInterfaces() {
            try {
                const response = await fetch('/api/network/interfaces');
                const interfaces = await response.json();

                const select = document.getElementById('interfaceSelect');
                select.innerHTML = '<option value="all">All Interfaces</option>';

                // Group interfaces by type
                const physical = interfaces.filter(i => i.type === 'physical');
                const docker = interfaces.filter(i => i.type === 'docker');
                const bridge = interfaces.filter(i => i.type === 'bridge');
                const veth = interfaces.filter(i => i.type === 'veth');

                // Add physical interfaces first
                if (physical.length > 0) {
                    const physGroup = document.createElement('optgroup');
                    physGroup.label = 'Physical Interfaces';
                    physical.forEach(iface => {
                        const option = document.createElement('option');
                        option.value = iface.name;
                        option.textContent = `${iface.name} (${iface.ip || 'no IP'})`;
                        physGroup.appendChild(option);
                    });
                    select.appendChild(physGroup);
                }

                // Add Docker interfaces
                if (docker.length > 0) {
                    const dockerGroup = document.createElement('optgroup');
                    dockerGroup.label = 'Docker Interfaces';
                    docker.forEach(iface => {
                        const option = document.createElement('option');
                        option.value = iface.name;
                        option.textContent = `${iface.name} (${iface.ip || 'no IP'})`;
                        dockerGroup.appendChild(option);
                    });
                    select.appendChild(dockerGroup);
                }

                // Add Bridge interfaces
                if (bridge.length > 0) {
                    const bridgeGroup = document.createElement('optgroup');
                    bridgeGroup.label = 'Bridge Interfaces';
                    bridge.forEach(iface => {
                        const option = document.createElement('option');
                        option.value = iface.name;
                        option.textContent = `${iface.name} (${iface.ip || 'no IP'})`;
                        bridgeGroup.appendChild(option);
                    });
                    select.appendChild(bridgeGroup);
                }

                // Add veth interfaces (usually many, so keep collapsed)
                if (veth.length > 0) {
                    const vethGroup = document.createElement('optgroup');
                    vethGroup.label = `Virtual Ethernet (${veth.length} interfaces)`;
                    veth.forEach(iface => {
                        const option = document.createElement('option');
                        option.value = iface.name;
                        option.textContent = `${iface.name} (${iface.ip || 'no IP'})`;
                        vethGroup.appendChild(option);
                    });
                    select.appendChild(vethGroup);
                }
            } catch (error) {
                console.error('Error loading interfaces:', error);
            }
        }

        async function startCapture() {
            const interface_ = document.getElementById('interfaceSelect').value;
            const filter = document.getElementById('filterInput').value;

            try {
                const response = await fetch('/api/network/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ interface: interface_, filter: filter })
                });

                if (response.ok) {
                    capturing = true;
                    captureStartTime = Date.now();

                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('recordingIndicator').classList.add('active');
                    document.getElementById('statusText').textContent = 'Capturing...';

                    // Start updating packet list
                    updateInterval = setInterval(fetchPackets, 500);

                    // Start capture timer
                    captureTimer = setInterval(updateCaptureTime, 1000);
                }
            } catch (error) {
                console.error('Error starting capture:', error);
                alert('Failed to start capture. Make sure you have necessary permissions.');
            }
        }

        async function stopCapture() {
            try {
                await fetch('/api/network/stop', { method: 'POST' });

                capturing = false;

                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('recordingIndicator').classList.remove('active');
                document.getElementById('statusText').textContent = 'Stopped';

                clearInterval(updateInterval);
                clearInterval(captureTimer);

                // Fetch final packets
                await fetchPackets();
            } catch (error) {
                console.error('Error stopping capture:', error);
            }
        }

        async function clearCapture() {
            if (capturing) {
                await stopCapture();
            }

            packets = [];
            displayedPackets = [];
            packetCounter = 0;
            selectedPacketId = null;

            updatePacketTable();
            document.getElementById('packetDetails').innerHTML = '<div class="no-data">Select a packet to view details</div>';
            document.getElementById('packetCount').textContent = '0';
            document.getElementById('displayedCount').textContent = '0';
            document.getElementById('captureTime').textContent = '0:00';

            try {
                await fetch('/api/network/clear', { method: 'POST' });
            } catch (error) {
                console.error('Error clearing capture:', error);
            }
        }

        async function fetchPackets() {
            try {
                const response = await fetch('/api/network/packets');
                const data = await response.json();

                packets = data.packets || [];
                displayedPackets = packets;

                updatePacketTable();
                document.getElementById('packetCount').textContent = packets.length;
                document.getElementById('displayedCount').textContent = displayedPackets.length;
            } catch (error) {
                console.error('Error fetching packets:', error);
            }
        }

        function updatePacketTable() {
            const tbody = document.getElementById('packetTableBody');

            if (displayedPackets.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="no-data">No packets to display</td></tr>';
                return;
            }

            const html = displayedPackets.map((packet, index) => {
                const selected = selectedPacketId === packet.id ? 'selected' : '';
                const protocolClass = `protocol-${packet.protocol.toLowerCase()}`;

                return `
                    <tr class="${selected}" onclick="selectPacket(${packet.id})">
                        <td>${packet.id}</td>
                        <td>${packet.time}</td>
                        <td>${packet.source}</td>
                        <td>${packet.destination}</td>
                        <td class="${protocolClass}">${packet.protocol}</td>
                        <td>${packet.length}</td>
                        <td>${packet.info}</td>
                    </tr>
                `;
            }).join('');

            tbody.innerHTML = html;
        }

        function selectPacket(packetId) {
            selectedPacketId = packetId;
            const packet = packets.find(p => p.id === packetId);

            if (packet) {
                displayPacketDetails(packet);
            }

            // Update selected row
            document.querySelectorAll('tbody tr').forEach(row => {
                row.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');
        }

        function displayPacketDetails(packet) {
            const details = document.getElementById('packetDetails');

            let html = '<h3>Packet Details</h3>';

            // Frame layer
            html += `
                <div class="layer">
                    <div class="layer-title">Frame ${packet.id}</div>
                    <div class="field"><span class="field-name">Arrival Time:</span> <span class="field-value">${packet.timestamp || 'N/A'}</span></div>
                    <div class="field"><span class="field-name">Frame Length:</span> <span class="field-value">${packet.length} bytes</span></div>
                    <div class="field"><span class="field-name">Protocol:</span> <span class="field-value">${packet.protocol}</span></div>
                </div>
            `;

            // Ethernet layer (if available)
            if (packet.layers && packet.layers.ethernet) {
                const eth = packet.layers.ethernet;
                html += `
                    <div class="layer">
                        <div class="layer-title">Ethernet II</div>
                        <div class="field"><span class="field-name">Source MAC:</span> <span class="field-value">${eth.src || 'N/A'}</span></div>
                        <div class="field"><span class="field-name">Destination MAC:</span> <span class="field-value">${eth.dst || 'N/A'}</span></div>
                        <div class="field"><span class="field-name">Type:</span> <span class="field-value">${eth.type || 'N/A'}</span></div>
                    </div>
                `;
            }

            // IP layer (if available)
            if (packet.layers && packet.layers.ip) {
                const ip = packet.layers.ip;
                html += `
                    <div class="layer">
                        <div class="layer-title">Internet Protocol Version ${ip.version || '4'}</div>
                        <div class="field"><span class="field-name">Source IP:</span> <span class="field-value">${packet.source}</span></div>
                        <div class="field"><span class="field-name">Destination IP:</span> <span class="field-value">${packet.destination}</span></div>
                        <div class="field"><span class="field-name">Protocol:</span> <span class="field-value">${ip.proto || packet.protocol}</span></div>
                        <div class="field"><span class="field-name">TTL:</span> <span class="field-value">${ip.ttl || 'N/A'}</span></div>
                    </div>
                `;
            }

            // Transport layer (TCP/UDP)
            if (packet.layers && packet.layers.tcp) {
                const tcp = packet.layers.tcp;
                html += `
                    <div class="layer">
                        <div class="layer-title">Transmission Control Protocol</div>
                        <div class="field"><span class="field-name">Source Port:</span> <span class="field-value">${tcp.sport || 'N/A'}</span></div>
                        <div class="field"><span class="field-name">Destination Port:</span> <span class="field-value">${tcp.dport || 'N/A'}</span></div>
                        <div class="field"><span class="field-name">Flags:</span> <span class="field-value">${tcp.flags || 'N/A'}</span></div>
                        <div class="field"><span class="field-name">Sequence Number:</span> <span class="field-value">${tcp.seq || 'N/A'}</span></div>
                    </div>
                `;
            } else if (packet.layers && packet.layers.udp) {
                const udp = packet.layers.udp;
                html += `
                    <div class="layer">
                        <div class="layer-title">User Datagram Protocol</div>
                        <div class="field"><span class="field-name">Source Port:</span> <span class="field-value">${udp.sport || 'N/A'}</span></div>
                        <div class="field"><span class="field-name">Destination Port:</span> <span class="field-value">${udp.dport || 'N/A'}</span></div>
                        <div class="field"><span class="field-name">Length:</span> <span class="field-value">${udp.len || 'N/A'} bytes</span></div>
                    </div>
                `;
            }

            // Industrial Protocol Layers

            // Modbus TCP
            if (packet.layers && packet.layers.modbus) {
                const modbus = packet.layers.modbus;
                html += `
                    <div class="layer" style="border-left-color: #ff6b6b;">
                        <div class="layer-title" style="color: #ff6b6b;">Modbus TCP Protocol</div>
                        <div class="field"><span class="field-name">Transaction ID:</span> <span class="field-value">${modbus.transaction_id}</span></div>
                        <div class="field"><span class="field-name">Protocol ID:</span> <span class="field-value">${modbus.protocol_id}</span></div>
                        <div class="field"><span class="field-name">Unit ID:</span> <span class="field-value">${modbus.unit_id}</span></div>
                        <div class="field"><span class="field-name">Function Code:</span> <span class="field-value">${modbus.function_code} (${modbus.function_name})</span></div>
                        <div class="field"><span class="field-name">Length:</span> <span class="field-value">${modbus.length} bytes</span></div>
                    </div>
                `;
            }

            // S7comm
            if (packet.layers && packet.layers.s7comm) {
                const s7 = packet.layers.s7comm;
                html += `
                    <div class="layer" style="border-left-color: #ffd93d;">
                        <div class="layer-title" style="color: #ffd93d;">S7 Communication Protocol</div>
                        ${s7.tpkt_length ? `<div class="field"><span class="field-name">TPKT Length:</span> <span class="field-value">${s7.tpkt_length} bytes</span></div>` : ''}
                        ${s7.protocol_id !== undefined ? `<div class="field"><span class="field-name">Protocol ID:</span> <span class="field-value">0x${s7.protocol_id.toString(16).padStart(2, '0')}</span></div>` : ''}
                        ${s7.message_type !== undefined ? `<div class="field"><span class="field-name">Message Type:</span> <span class="field-value">${s7.message_type} (${s7.message_type_name})</span></div>` : ''}
                    </div>
                `;
            }

            // OPC-UA
            if (packet.layers && packet.layers.opcua) {
                const opcua = packet.layers.opcua;
                html += `
                    <div class="layer" style="border-left-color: #a8e6cf;">
                        <div class="layer-title" style="color: #a8e6cf;">OPC Unified Architecture</div>
                        <div class="field"><span class="field-name">Message Type:</span> <span class="field-value">${opcua.message_type} (${opcua.message_type_name})</span></div>
                        <div class="field"><span class="field-name">Chunk Type:</span> <span class="field-value">${opcua.chunk_type} (${opcua.chunk_type_name})</span></div>
                        <div class="field"><span class="field-name">Message Size:</span> <span class="field-value">${opcua.message_size} bytes</span></div>
                    </div>
                `;
            }

            // EtherNet/IP
            if (packet.layers && packet.layers.enip) {
                const enip = packet.layers.enip;
                html += `
                    <div class="layer" style="border-left-color: #ff8b94;">
                        <div class="layer-title" style="color: #ff8b94;">EtherNet/IP Protocol</div>
                        <div class="field"><span class="field-name">Command:</span> <span class="field-value">0x${enip.command.toString(16).padStart(4, '0')} (${enip.command_name})</span></div>
                        <div class="field"><span class="field-name">Length:</span> <span class="field-value">${enip.length} bytes</span></div>
                        <div class="field"><span class="field-name">Session Handle:</span> <span class="field-value">0x${enip.session_handle.toString(16).padStart(8, '0')}</span></div>
                        <div class="field"><span class="field-name">Status:</span> <span class="field-value">0x${enip.status.toString(16).padStart(8, '0')}</span></div>
                    </div>
                `;
            }

            // Application layer data
            if (packet.data) {
                html += `
                    <div class="layer">
                        <div class="layer-title">Payload Data</div>
                        <div class="field"><span class="field-value">${packet.data}</span></div>
                    </div>
                `;
            }

            details.innerHTML = html;
        }

        function updateCaptureTime() {
            if (captureStartTime) {
                const elapsed = Math.floor((Date.now() - captureStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('captureTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        function applyFilter() {
            const filterText = document.getElementById('filterInput').value.toLowerCase();

            if (!filterText) {
                displayedPackets = packets;
            } else {
                displayedPackets = packets.filter(packet => {
                    return packet.protocol.toLowerCase().includes(filterText) ||
                           packet.source.includes(filterText) ||
                           packet.destination.includes(filterText) ||
                           packet.info.toLowerCase().includes(filterText) ||
                           (packet.source_port && packet.source_port.toString().includes(filterText)) ||
                           (packet.dest_port && packet.dest_port.toString().includes(filterText));
                });
            }

            updatePacketTable();
            document.getElementById('displayedCount').textContent = displayedPackets.length;
        }

        async function exportCapture() {
            try {
                const response = await fetch('/api/network/export');

                if (!response.ok) {
                    throw new Error('Export failed');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Get filename from Content-Disposition header if available
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = `capture_${new Date().toISOString().replace(/[:.]/g, '-')}.pcap`;

                if (contentDisposition) {
                    const filenameMatch = contentDisposition.match(/filename="?(.+)"?/i);
                    if (filenameMatch) {
                        filename = filenameMatch[1];
                    }
                }

                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                console.log(`Exported ${packets.length} packets to ${filename}`);
            } catch (error) {
                console.error('Error exporting capture:', error);
                alert('Failed to export capture data. Make sure packets have been captured.');
            }
        }

        // ===== NETWORK GRAPH VISUALIZATION =====

        let graphCanvas, graphCtx;
        let graphNodes = new Map();
        let graphEdges = [];
        let graphScale = 1;
        let graphOffsetX = 0;
        let graphOffsetY = 0;
        let graphDragging = false;
        let graphDragStartX = 0;
        let graphDragStartY = 0;
        let graphSelectedNode = null;

        function switchView(view, event) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            }

            // Update views
            document.querySelectorAll('.view-content').forEach(content => content.classList.remove('active'));

            if (view === 'packets') {
                document.getElementById('packetsView').classList.add('active');
            } else if (view === 'graph') {
                document.getElementById('graphView').classList.add('active');
                setTimeout(() => {
                    initGraph();
                    updateGraph();
                }, 100);
            } else if (view === 'statistics') {
                document.getElementById('statisticsView').classList.add('active');
                updateStatistics();
            }
        }

        function updateStatistics() {
            if (packets.length === 0) return;

            // Calculate basic stats
            const totalPackets = packets.length;
            const totalBytes = packets.reduce((sum, p) => sum + (p.length || 0), 0);
            const avgSize = Math.round(totalBytes / totalPackets);

            // Calculate duration and rate
            const duration = captureStartTime ? Math.floor((Date.now() - captureStartTime) / 1000) : 0;
            const pps = duration > 0 ? (totalPackets / duration).toFixed(2) : 0;
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;

            // Update summary
            document.getElementById('stats-total-packets').textContent = totalPackets.toLocaleString();
            document.getElementById('stats-total-bytes').textContent = formatBytes(totalBytes);
            document.getElementById('stats-duration').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('stats-pps').textContent = pps;
            document.getElementById('stats-avg-size').textContent = `${avgSize} bytes`;

            // Protocol distribution
            const protocolCount = {};
            packets.forEach(p => {
                protocolCount[p.protocol] = (protocolCount[p.protocol] || 0) + 1;
            });

            const protocolStatsHtml = Object.entries(protocolCount)
                .sort((a, b) => b[1] - a[1])
                .map(([protocol, count]) => {
                    const percentage = ((count / totalPackets) * 100).toFixed(1);
                    return `
                        <div class="stat-row">
                            <span class="stat-label">${protocol}</span>
                            <span class="stat-value">${count} (${percentage}%)</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percentage}%">
                                ${percentage >= 10 ? percentage + '%' : ''}
                            </div>
                        </div>
                    `;
                }).join('');
            document.getElementById('protocol-stats').innerHTML = protocolStatsHtml;

            // Endpoint analysis
            const endpoints = new Map();
            const connections = new Map();
            let industrialCount = 0;

            packets.forEach(p => {
                if (!p.source || p.source === 'N/A') return;
                if (!p.destination || p.destination === 'N/A') return;

                // Track source
                if (!endpoints.has(p.source)) {
                    const type = getNodeType(p.source, p);
                    if (type === 'industrial') industrialCount++;
                    endpoints.set(p.source, {
                        ip: p.source,
                        type: type,
                        sent: 0,
                        received: 0,
                        bytes: 0,
                        protocols: new Set()
                    });
                }
                const src = endpoints.get(p.source);
                src.sent++;
                src.bytes += p.length || 0;
                src.protocols.add(p.protocol);

                // Track destination
                if (!endpoints.has(p.destination)) {
                    const type = getNodeType(p.destination, p);
                    if (type === 'industrial') industrialCount++;
                    endpoints.set(p.destination, {
                        ip: p.destination,
                        type: type,
                        sent: 0,
                        received: 0,
                        bytes: 0,
                        protocols: new Set()
                    });
                }
                const dst = endpoints.get(p.destination);
                dst.received++;

                // Track connections
                const connKey = `${p.source}-${p.destination}`;
                if (!connections.has(connKey)) {
                    connections.set(connKey, {
                        source: p.source,
                        destination: p.destination,
                        protocol: p.protocol,
                        count: 0,
                        ports: new Set()
                    });
                }
                const conn = connections.get(connKey);
                conn.count++;
                if (p.source_port && p.dest_port) {
                    conn.ports.add(`${p.source_port}→${p.dest_port}`);
                }
                if (p.protocol !== 'TCP' && p.protocol !== 'UDP') {
                    conn.protocol = p.protocol;
                }
            });

            document.getElementById('stats-unique-ips').textContent = endpoints.size;
            document.getElementById('stats-connections').textContent = connections.size;
            document.getElementById('stats-industrial').textContent = industrialCount;

            // Top ports
            const portCount = {};
            packets.forEach(p => {
                if (p.source_port) portCount[p.source_port] = (portCount[p.source_port] || 0) + 1;
                if (p.dest_port) portCount[p.dest_port] = (portCount[p.dest_port] || 0) + 1;
            });

            const portStatsHtml = Object.entries(portCount)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([port, count]) => {
                    const portName = getPortName(port);
                    return `
                        <div class="stat-row">
                            <span class="stat-label">${port} ${portName ? '(' + portName + ')' : ''}</span>
                            <span class="stat-value">${count}</span>
                        </div>
                    `;
                }).join('');
            document.getElementById('port-stats').innerHTML = portStatsHtml || '<div class="stat-row"><span class="stat-label">No port data</span></div>';

            // Endpoint table
            const endpointTableHtml = Array.from(endpoints.values())
                .sort((a, b) => (b.sent + b.received) - (a.sent + a.received))
                .map(ep => {
                    const total = ep.sent + ep.received;
                    const protocols = Array.from(ep.protocols).map(p =>
                        `<span class="protocol-badge badge-${p.toLowerCase()}">${p}</span>`
                    ).join(' ');
                    const typeColor = ep.type === 'industrial' ? '#ff6b6b' : ep.type === 'network' ? '#66ccff' : '#99ff99';
                    return `
                        <tr>
                            <td><strong>${ep.ip}</strong></td>
                            <td><span style="color: ${typeColor}">●</span> ${ep.type}</td>
                            <td>${ep.sent.toLocaleString()}</td>
                            <td>${ep.received.toLocaleString()}</td>
                            <td><strong>${total.toLocaleString()}</strong></td>
                            <td>${formatBytes(ep.bytes)}</td>
                            <td>${protocols}</td>
                        </tr>
                    `;
                }).join('');
            document.getElementById('endpoint-table-body').innerHTML = endpointTableHtml || '<tr><td colspan="7">No endpoint data</td></tr>';

            // Connection matrix
            const connectionTableHtml = Array.from(connections.values())
                .sort((a, b) => b.count - a.count)
                .slice(0, 20)
                .map(conn => {
                    const ports = Array.from(conn.ports).join(', ');
                    return `
                        <tr>
                            <td>${conn.source}</td>
                            <td>${conn.destination}</td>
                            <td><span class="protocol-badge badge-${conn.protocol.toLowerCase()}">${conn.protocol}</span></td>
                            <td><strong>${conn.count.toLocaleString()}</strong></td>
                            <td>${ports || 'N/A'}</td>
                        </tr>
                    `;
                }).join('');
            document.getElementById('connection-table-body').innerHTML = connectionTableHtml || '<tr><td colspan="5">No connection data</td></tr>';
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function getPortName(port) {
            const portNames = {
                '502': 'Modbus',
                '102': 'S7comm',
                '4840': 'OPC-UA',
                '44818': 'EtherNet/IP',
                '80': 'HTTP',
                '443': 'HTTPS',
                '22': 'SSH',
                '23': 'Telnet',
                '21': 'FTP',
                '53': 'DNS'
            };
            return portNames[port] || '';
        }

        function initGraph() {
            if (graphCanvas) {
                console.log('Graph already initialized');
                return; // Already initialized
            }

            console.log('Initializing graph');
            graphCanvas = document.getElementById('graphCanvas');

            if (!graphCanvas) {
                console.error('Canvas element not found');
                return;
            }

            graphCtx = graphCanvas.getContext('2d');
            console.log('Canvas context created');

            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Mouse events
            graphCanvas.addEventListener('mousedown', graphMouseDown);
            graphCanvas.addEventListener('mousemove', graphMouseMove);
            graphCanvas.addEventListener('mouseup', graphMouseUp);
            graphCanvas.addEventListener('wheel', graphWheel, { passive: false });

            console.log('Graph initialization complete');
        }

        function resizeCanvas() {
            if (!graphCanvas) return;
            graphCanvas.width = graphCanvas.offsetWidth;
            graphCanvas.height = graphCanvas.offsetHeight;
            drawGraph();
        }

        function updateGraph() {
            console.log('Updating graph with', packets.length, 'packets');

            // Analyze packets to build nodes and edges
            graphNodes.clear();
            graphEdges = [];

            const connectionCount = new Map(); // Track connection strength

            packets.forEach(packet => {
                const src = packet.source;
                const dst = packet.destination;

                if (!src || !dst || src === 'N/A' || dst === 'N/A') return;

                // Add nodes with better initial spacing
                if (!graphNodes.has(src)) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = 200 + Math.random() * 100;
                    graphNodes.set(src, {
                        id: src,
                        label: src,
                        type: getNodeType(src, packet),
                        x: 400 + Math.cos(angle) * radius,
                        y: 300 + Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0
                    });
                }

                if (!graphNodes.has(dst)) {
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = 200 + Math.random() * 100;
                    graphNodes.set(dst, {
                        id: dst,
                        label: dst,
                        type: getNodeType(dst, packet),
                        x: 400 + Math.cos(angle) * radius,
                        y: 300 + Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0
                    });
                }

                // Track connections
                const edgeKey = `${src}-${dst}`;
                const reverseEdgeKey = `${dst}-${src}`;

                if (!connectionCount.has(edgeKey) && !connectionCount.has(reverseEdgeKey)) {
                    connectionCount.set(edgeKey, {
                        source: src,
                        target: dst,
                        protocol: packet.protocol,
                        sourcePort: packet.source_port,
                        destPort: packet.dest_port,
                        count: 1
                    });
                } else {
                    const key = connectionCount.has(edgeKey) ? edgeKey : reverseEdgeKey;
                    const conn = connectionCount.get(key);
                    conn.count++;
                    // Keep the most common protocol for this connection
                    if (packet.protocol !== 'TCP' && packet.protocol !== 'UDP') {
                        conn.protocol = packet.protocol;
                    }
                    // Update ports if we have better info
                    if (packet.source_port) conn.sourcePort = packet.source_port;
                    if (packet.dest_port) conn.destPort = packet.dest_port;
                }
            });

            // Create edges from connections
            connectionCount.forEach(conn => {
                graphEdges.push({
                    source: conn.source,
                    target: conn.target,
                    protocol: conn.protocol,
                    sourcePort: conn.sourcePort,
                    destPort: conn.destPort,
                    weight: Math.min(conn.count / 10, 5), // Line thickness
                    color: getEdgeColor(conn.protocol),
                    label: conn.sourcePort && conn.destPort ? `${conn.sourcePort}→${conn.destPort}` : ''
                });
            });

            console.log('Graph nodes:', graphNodes.size, 'Graph edges:', graphEdges.length);

            // Log node details
            if (graphNodes.size > 0) {
                console.log('Node details:');
                graphNodes.forEach((node, id) => {
                    console.log(`  ${id}: pos(${node.x.toFixed(1)}, ${node.y.toFixed(1)}) type:${node.type}`);
                });
            }

            // Run force-directed layout
            if (graphNodes.size > 0) {
                graphAutoLayout();
            } else {
                // Draw empty state
                drawGraph();
            }
        }

        function getNodeType(ip, packet) {
            // Determine node type based on protocol and ports
            const protocol = packet.protocol;
            const ports = [packet.source_port, packet.dest_port].filter(p => p);

            // Industrial protocols
            if (['MODBUS', 'S7COMM', 'OPCUA', 'ENIP'].includes(protocol)) {
                return 'industrial';
            }

            // Common industrial ports
            if (ports.includes(502) || ports.includes(102) || ports.includes(4840) || ports.includes(44818)) {
                return 'industrial';
            }

            // Network infrastructure
            if (ip.endsWith('.1') || ip.endsWith('.254')) {
                return 'network';
            }

            return 'other';
        }

        function getNodeColor(type) {
            switch (type) {
                case 'industrial': return '#ff6b6b';
                case 'network': return '#66ccff';
                default: return '#99ff99';
            }
        }

        function getEdgeColor(protocol) {
            if (protocol === 'MODBUS') return '#ff6b6b';
            if (protocol === 'S7COMM') return '#ffd93d';
            if (protocol === 'OPCUA') return '#a8e6cf';
            if (protocol === 'ENIP') return '#ff8b94';
            return '#66ccff';
        }

        function graphAutoLayout() {
            if (graphNodes.size === 0) return;

            console.log('Running auto layout...');

            // Simple force-directed layout algorithm
            const iterations = 100; // More iterations for better layout
            const k = 150; // Increased optimal distance to spread nodes
            const c = 0.4; // Damping
            const repulsionStrength = 2.0; // Stronger repulsion to prevent overlap

            for (let iter = 0; iter < iterations; iter++) {
                // Calculate repulsive forces between all nodes
                graphNodes.forEach(node1 => {
                    node1.fx = 0;
                    node1.fy = 0;

                    graphNodes.forEach(node2 => {
                        if (node1.id === node2.id) return;

                        const dx = node1.x - node2.x;
                        const dy = node1.y - node2.y;
                        const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 10);

                        // Stronger repulsion to prevent overlap (inverse square law)
                        const force = repulsionStrength * (k * k) / (dist * dist);
                        node1.fx += (dx / dist) * force;
                        node1.fy += (dy / dist) * force;
                    });
                });

                // Calculate attractive forces for edges
                graphEdges.forEach(edge => {
                    const source = graphNodes.get(edge.source);
                    const target = graphNodes.get(edge.target);

                    if (!source || !target) return;

                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 1);

                    // Attraction (spring force)
                    const force = dist / k;
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;

                    source.fx += fx;
                    source.fy += fy;
                    target.fx -= fx;
                    target.fy -= fy;
                });

                // Update positions
                graphNodes.forEach(node => {
                    node.vx = (node.vx || 0) + node.fx;
                    node.vy = (node.vy || 0) + node.fy;
                    node.vx *= c;
                    node.vy *= c;
                    node.x += node.vx;
                    node.y += node.vy;

                    // Keep values finite
                    if (!isFinite(node.x)) node.x = 300;
                    if (!isFinite(node.y)) node.y = 300;
                });
            }

            console.log('Layout complete, final positions:');
            graphNodes.forEach((node, id) => {
                console.log(`  ${id}: (${node.x.toFixed(1)}, ${node.y.toFixed(1)})`);
            });

            // Center the graph
            graphResetView();
        }

        function drawGraph() {
            if (!graphCtx) {
                console.warn('Graph context not initialized');
                return;
            }

            const ctx = graphCtx;
            const width = graphCanvas.width;
            const height = graphCanvas.height;

            console.log('Drawing graph, canvas size:', width, 'x', height);

            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);

            // Draw empty state message if no nodes
            if (graphNodes.size === 0) {
                ctx.fillStyle = '#ff6b00';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🦈 Sharky Network Graph', width / 2, height / 2 - 40);

                ctx.fillStyle = '#999';
                ctx.font = '16px Arial';
                ctx.fillText('Start capturing packets to see network topology', width / 2, height / 2);

                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.fillText('Click "▶ Start" in the toolbar above', width / 2, height / 2 + 30);
                ctx.fillText('Then switch back to this tab to see the graph', width / 2, height / 2 + 55);
                return;
            }

            ctx.save();
            ctx.translate(graphOffsetX, graphOffsetY);
            ctx.scale(graphScale, graphScale);

            // Draw edges
            graphEdges.forEach(edge => {
                const source = graphNodes.get(edge.source);
                const target = graphNodes.get(edge.target);

                if (!source || !target) return;

                ctx.strokeStyle = edge.color;
                ctx.lineWidth = Math.max(edge.weight || 1, 2);
                ctx.globalAlpha = 0.7;

                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();

                // Draw port label on edge
                if (edge.label) {
                    const midX = (source.x + target.x) / 2;
                    const midY = (source.y + target.y) / 2;

                    // Background for label
                    ctx.globalAlpha = 0.9;
                    ctx.fillStyle = '#2d2d2d';
                    const labelMetrics = ctx.measureText(edge.label);
                    const labelWidth = labelMetrics.width + 8;
                    const labelHeight = 16;
                    ctx.fillRect(midX - labelWidth / 2, midY - labelHeight / 2, labelWidth, labelHeight);

                    // Label text
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = edge.color;
                    ctx.font = 'bold 11px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(edge.label, midX, midY);
                }
            });

            ctx.globalAlpha = 1;

            // Draw nodes
            graphNodes.forEach(node => {
                const color = getNodeColor(node.type);

                // Node circle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fill();

                // Node border
                ctx.strokeStyle = graphSelectedNode === node.id ? '#ff6b00' : '#ffffff';
                ctx.lineWidth = graphSelectedNode === node.id ? 3 : 1;
                ctx.stroke();

                // Node label
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(node.label, node.x, node.y + 35);
            });

            ctx.restore();
        }

        function graphMouseDown(e) {
            const rect = graphCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Check if clicking on a node
            const clickedNode = getNodeAtPosition(x, y);

            if (clickedNode) {
                graphSelectedNode = clickedNode.id;
                drawGraph();
            } else {
                graphDragging = true;
                graphDragStartX = x - graphOffsetX;
                graphDragStartY = y - graphOffsetY;
            }
        }

        function graphMouseMove(e) {
            if (!graphDragging) return;

            const rect = graphCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            graphOffsetX = x - graphDragStartX;
            graphOffsetY = y - graphDragStartY;

            drawGraph();
        }

        function graphMouseUp(e) {
            graphDragging = false;
        }

        function graphWheel(e) {
            e.preventDefault();

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            graphScale *= delta;
            graphScale = Math.max(0.1, Math.min(graphScale, 5));

            drawGraph();
        }

        function getNodeAtPosition(x, y) {
            // Transform coordinates
            const tx = (x - graphOffsetX) / graphScale;
            const ty = (y - graphOffsetY) / graphScale;

            for (const node of graphNodes.values()) {
                const dx = tx - node.x;
                const dy = ty - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 20) {
                    return node;
                }
            }

            return null;
        }

        function graphZoomIn() {
            graphScale *= 1.2;
            graphScale = Math.min(graphScale, 5);
            drawGraph();
        }

        function graphZoomOut() {
            graphScale *= 0.8;
            graphScale = Math.max(graphScale, 0.1);
            drawGraph();
        }

        function graphResetView() {
            if (graphNodes.size === 0) {
                graphScale = 1;
                graphOffsetX = 0;
                graphOffsetY = 0;
                drawGraph();
                return;
            }

            console.log('Calculating bounding box for', graphNodes.size, 'nodes');

            // Calculate bounding box
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            graphNodes.forEach((node, id) => {
                console.log(`  Node ${id}: x=${node.x}, y=${node.y}`);

                if (isFinite(node.x) && isFinite(node.y)) {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x);
                    maxY = Math.max(maxY, node.y);
                } else {
                    console.warn(`  Node ${id} has invalid coordinates!`);
                }
            });

            console.log('Bounding box:', {minX, minY, maxX, maxY});

            const graphWidth = maxX - minX + 200;
            const graphHeight = maxY - minY + 200;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            console.log('Graph dimensions:', {graphWidth, graphHeight, centerX, centerY});

            // Calculate scale to fit (with padding)
            const scaleX = graphCanvas.width / graphWidth;
            const scaleY = graphCanvas.height / graphHeight;
            graphScale = Math.min(scaleX, scaleY, 2.0);

            console.log('Calculated scale:', graphScale);

            // Center the graph
            graphOffsetX = graphCanvas.width / 2 - centerX * graphScale;
            graphOffsetY = graphCanvas.height / 2 - centerY * graphScale;

            console.log('Offset:', {graphOffsetX, graphOffsetY});

            drawGraph();
        }

        // Update graph when packets change
        const originalFetchPackets = fetchPackets;
        fetchPackets = async function() {
            await originalFetchPackets();
            if (document.getElementById('graphView').classList.contains('active')) {
                updateGraph();
            }
        };
    </script>
</body>
</html>
